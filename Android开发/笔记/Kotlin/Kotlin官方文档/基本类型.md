在 Kotlin 中，所有东西都是对象，在这个意义上讲可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。

本节会描述 Kotlin 中使用的基本类型：

- [数字](https://book.kotlincn.net/text/numbers.html)及其[无符号版](https://book.kotlincn.net/text/unsigned-integer-types.html)
- [布尔](https://book.kotlincn.net/text/booleans.html)
- [字符](https://book.kotlincn.net/text/characters.html)
- [字符串](https://book.kotlincn.net/text/strings.html)
- [数组](https://book.kotlincn.net/text/arrays.html)在 Kotlin 中，所有东西都是对象，在这个意义上讲可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。

本节会描述 Kotlin 中使用的基本类型：

数字及其无符号版
布尔
字符
字符串
数组




# 数字

## 整数类型

Kotlin 提供了一组表示数字的内置类型。 对于整数，有四种不同大小的类型，因此值的范围也不同：

|类型|大小（比特数）|最小值|最大值|
|---|---|---|---|
|`Byte`|8|-128|127|
|`Short`|16|-32768|32767|
|`Int`|32|-2,147,483,648 (-231)|2,147,483,647 (231 - 1)|
|`Long`|64|-9,223,372,036,854,775,808 (-263)|9,223,372,036,854,775,807 (263 - 1)|

当初始化一个没有显式指定类型的变量时，编译器会自动推断为自 `Int` 起足以表示该值的最小类型。 如果不超过 `Int` 的表示范围，那么类型是 `Int`。 如果超过了，那么类型是 `Long`。 如需显式指定 `Long` 值，请给该值追加后缀 `L`。 显式指定类型会触发编译器检测该值是否超出指定类型的表示范围。

```
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

> 除了整数类型之外，Kotlin 还提供无符号整数类型。 更多信息请参见[无符号整数类型](https://book.kotlincn.net/text/unsigned-integer-types.html)。

## 浮点类型

对于实数，Kotlin 提供了浮点类型 `Float` 与 `Double` 类型，遵循 [IEEE 754 标准](https://zh.wikipedia.org/wiki/IEEE_754)。 `Float` 表达 IEEE 754 _单精度_，而 `Double` 表达_双精度_。

这两个类型的大小不同，并为两种不同精度的浮点数提供存储：

|类型|大小（比特数）|有效数字比特数|指数比特数|十进制位数|
|---|---|---|---|---|
|`Float`|32|24|8|6-7|
|`Double`|64|53|11|15-16|

可以使用带小数部分的数字初始化 `Double` 与 `Float` 变量。 小数部分与整数部分之间用句点（`.`）分隔 对于以小数初始化的变量，编译器会推断为 `Double` 类型：

```
val pi = 3.14 // Double
// val one: Double = 1 // 错误：类型不匹配
val oneDouble = 1.0 // Double
```

如需将一个值显式指定为 `Float` 类型，请添加 `f` 或 `F` 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入：

```
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float，实际值为 2.7182817
```

与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。 例如，具有 `Double` 参数的函数只能对 `Double` 值调用，而不能对 `Float`、 `Int` 或者其他数字值调用：

```
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//    printDouble(i) // 错误：类型不匹配
//    printDouble(f) // 错误：类型不匹配
}
```

如需将数值转换为不同的类型，请使用[显式转换](https://book.kotlincn.net/text/numbers.html#%E6%98%BE%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2)。

## 数字字面常量

数值常量字面值有以下几种:

- 十进制: `123`
    - Long 类型用大写 `L` 标记: `123L`
- 十六进制: `0x0F`
- 二进制: `0b00001011`

> Kotlin 不支持八进制。

Kotlin 同样支持浮点数的常规表示方法:

- 默认 double：`123.5`、`123.5e10`
- Float 用 `f` 或者 `F` 标记: `123.5f`

你可以使用下划线使数字常量更易读：

```
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

> 无符号整数字面值也有特殊标记。  
> 更多内容请参阅[无符号整型字面值](https://book.kotlincn.net/text/unsigned-integer-types.html)。

## JVM 平台的数字表示

在 JVM 平台数字存储为原生类型 `int`、 `double` 等。 例外情况是当创建可空数字引用如 `Int?` 或者使用泛型时。 在这些场景中，数字会装箱为 Java 类 `Integer`、 `Double` 等。

对相同数字的可为空引用可能会引用不同的对象：

```
fun main() {
//sampleStart
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a

    val b: Int = 10000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b

    println(boxedA === anotherBoxedA) // true
    println(boxedB === anotherBoxedB) // false
//sampleEnd
}
```

由于 JVM 对 `-128` 到 `127` 的整数（`Integer`）应用了内存优化，因此，`a` 的所有可空引用实际上都是同一对象。但是没有对 `b` 应用内存优化，所以它们是不同对象。

另一方面，它们仍然相等:

```
fun main() {
//sampleStart
    val b: Int = 10000
    println(b == b) // 输出“true”
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    println(boxedB == anotherBoxedB) // 输出“true”
//sampleEnd
}
```

## 显式数字转换

由于不同的表示方式，较小类型并_不是_较大类型的子类型。 如果它们是的话，就会出现下述问题：

```
// 假想的代码，实际上并不能编译：
val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)
val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)
print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long
```

所以会悄无声息地失去相等性，更别说同一性了。

因此较小的类型_**不能** 隐式转换_为较大的类型。 这意味着把 `Byte` 型值赋给一个 `Int` 变量必须显式转换：

```
fun main() {
//sampleStart
    val b: Byte = 1 // OK, 字面值会静态检测
    // val i: Int = b // 错误
    val i1: Int = b.toInt()
//sampleEnd
}
```

所有数字类型都支持转换为其他类型：

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`

很多情况都不需要显式类型转换，因为类型会从上下文推断出来， 而算术运算会有重载做适当转换，例如：

```
val l = 1L + 3 // Long + Int => Long
```

## 数字运算

Kotlin支持数字运算的标准集：`+`、 `-`、 `*`、 `/`、 `%`。它们已定义为相应的类成员：

```
fun main() {
//sampleStart
    println(1 + 2)
    println(2_500_000_000L - 1L)
    println(3.14 * 2.71)
    println(10.0 / 3)
//sampleEnd
}
```

还可以为自定义类覆盖这些操作符。详情请参见[操作符重载](https://book.kotlincn.net/text/operator-overloading.html)。

### 整数除法

整数间的除法总是返回整数。会丢弃任何小数部分。

```
fun main() {
//sampleStart
    val x = 5 / 2
    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'
    println(x == 2)
//sampleEnd
}
```

对于任何两个整数类型之间的除法来说都是如此：

```
fun main() {
//sampleStart
    val x = 5L / 2
    println(x == 2L)
//sampleEnd
}
```

如需返回浮点类型，请将其中的一个参数显式转换为浮点类型：

```
fun main() {
//sampleStart
    val x = 5 / 2.toDouble()
    println(x == 2.5)
//sampleEnd
}
```

### 位运算

Kotlin 对整数提供了一组_位运算_。它们直接使用数字的比特表示在二进制级别进行操作。 位运算有可以通过中缀形式调用的函数表示。只能应用于 `Int` 与 `Long`：

```
val x = (1 shl 2) and 0x000FF000
```

这是完整的位运算列表：

- `shl(bits)` – 有符号左移
- `shr(bits)` – 有符号右移
- `ushr(bits)` – 无符号右移
- `and(bits)` – 位**与**
- `or(bits)` – 位**或**
- `xor(bits)` – 位**异或**
- `inv()` – 位非

### 浮点数比较

本节讨论的浮点数操作如下：

- 相等性检测：`a == b` 与 `a != b`
- 比较操作符：`a < b`、 `a > b`、 `a <= b`、 `a >= b`
- 区间实例以及区间检测：`a..b`、 `x in a..b`、 `x !in a..b`

当其中的操作数 `a` 与 `b` 都是静态已知的 `Float` 或 `Double` 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者[智能类型转换](https://book.kotlincn.net/text/typecasts.html#%E6%99%BA%E8%83%BD%E8%BD%AC%E6%8D%A2)的结果是该类型），两数字所形成的操作或者区间遵循 [IEEE 754 浮点运算标准](https://zh.wikipedia.org/wiki/IEEE_754)。

然而，为了支持泛型场景并提供全序支持，对于**并非**静态类型就是浮点数的情况，行为是不同的。例如是 `Any`、 `Comparable<...>` 或者 `Collection<T>` 类型。 这种情况下，这些操作使用为 `Float` 与 `Double` 实现的 `equals` 与 `compareTo`。 因此：

- 认为 `NaN` 与其自身相等
- 认为 `NaN` 比包括正无穷大（`POSITIVE_INFINITY`）在内的任何其他元素都大
- 认为 `-0.0` 小于 `0.0`

以下示例显示了静态类型作为浮点数 （`Double.NaN`）的操作数与静态类型**并非**作为浮点数的操作数（`listOf(T)`）之间的行为差异。

```
fun main() {
    //sampleStart
    // 静态类型作为浮点数的操作数
    println(Double.NaN == Double.NaN)                 // false
    // 静态类型并非作为浮点数的操作数
    // 所以 NaN 等于它本身
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true

    // 静态类型作为浮点数的操作数
    println(0.0 == -0.0)                              // true
    // 静态类型并非作为浮点数的操作数
    // 所以 -0.0 小于 0.0
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
```



# 布尔

`Boolean` 类型表示可以有 `true` 与 `false` 两个值的布尔对象。

`Boolean` 的可空版 `Boolean?` 还有 `null` 值。

布尔值的内置运算有：

- `||`——析取（逻辑_或_）
- `&&`——合取（逻辑_与_）
- `!`——否定（逻辑_非_）

`||` 与 `&&` 都是惰性（短路）的。

```
fun main() {
//sampleStart
    val myTrue: Boolean = true
    val myFalse: Boolean = false
    val boolNull: Boolean? = null

    println(myTrue || myFalse)
    println(myTrue && myFalse)
    println(!myTrue)
//sampleEnd
}
```

> **JVM 平台**： 布尔对象的可空引用会装箱，类似于[数字](https://book.kotlincn.net/text/numbers.html#jvm-%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA)。


# 字符

字符用 `Char` 类型表示。 字符字面值用单引号括起来: `'1'`。

特殊字符可以以转义反斜杠 `\` 开始。 支持这几个转义序列：

- `\t`——制表符
- `\b`——退格符
- `\n`——换行（LF）
- `\r`——回车（CR）
- `\'`——单引号
- `\"`——双引号
- `\\`——反斜杠
- `\$`——美元符

编码其他字符要用 Unicode 转义序列语法：`'\uFF00'`。

```
fun main() {
//sampleStart
    val aChar: Char = 'a'

    println(aChar)
    println('\n') // 输出一个额外的换行符
    println('\uFF00')
//sampleEnd
}
```

如果字符变量的值是数字，那么可以使用 [`digitToInt()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/digit-to-int.html) 函数将其显式转换为 `Int` 数字。

> **JVM 平台**： 与[数字](https://book.kotlincn.net/text/numbers.html#jvm-%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA)一样，当需要可空引用时会将字符装箱。装箱操作不保留同一性。

# 字符串

Kotlin 中字符串用 [`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/) 类型表示。 通常，字符串值是双引号（`"`）中的字符序列：

```
val str = "abcd 123"
```

字符串的元素——字符可以使用索引运算符访问: `s[i]`。 可以使用 `for` 循环遍历这些字符：

```
fun main() {
val str = "abcd"
//sampleStart
for (c in str) {
    println(c)
}
//sampleEnd
}
```

字符串是不可变的。 一旦初始化了一个字符串，就不能改变它的值或者给它赋新值。 所有转换字符串的操作都以一个新的 `String` 对象来返回结果，而保持原始字符串不变：

```
fun main() {
//sampleStart
    val str = "abcd"
    println(str.uppercase()) // 创建并输出一个新的 String 对象
    println(str) // 原始字符串保持不变
//sampleEnd
}
```

如需连接字符串，可以用 `+` 操作符。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串：

```
fun main() {
//sampleStart
val s = "abc" + 1
println(s + "def")
//sampleEnd
}
```

> 在大多数情况下，优先使用[字符串模板](https://book.kotlincn.net/text/strings.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF)或[多行字符串](https://book.kotlincn.net/text/strings.html#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)而不是字符串连接。

## 字符串字面值

Kotlin 有两种类型的字符串字面值:

- [转义字符串](https://book.kotlincn.net/text/strings.html#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2)
- [多行字符串](https://book.kotlincn.net/text/strings.html#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)

### 转义字符串

_转义字符串_可以包含转义字符。  
以下是转义字符串的一个示例：

```
val s = "Hello, world!\n"
```

转义采用传统的反斜杠（`\`）方式。  
所支持的转义序列请参见 [字符](https://book.kotlincn.net/text/characters.html) 页。

### 多行字符串

_多行字符串_可以包含换行以及任意文本。 它使用三个引号（`"""`）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符：

```
val text = """
    for (c in "foo")
        print(c)
"""
```

如需删掉多行字符串中的前导空格，请使用 [`trimMargin()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html) 函数：

```
val text = """
|Tell me and I forget.
|Teach me and I remember.
|Involve me and I learn.
|(Benjamin Franklin)
    """.trimMargin()
```

默认以竖线 `|` 作为边界前缀，但你可以选择其他字符并作为参数传入，比如 `trimMargin(">")`。

## 字符串模板

字符串字面值可以包含_模板表达式_——一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（`$`）开头，要么由一个的名称构成:

```
fun main() {
//sampleStart
    val i = 10
    println("i = $i") // 输出“i = 10”
//sampleEnd
}
```

要么是用花括号括起来的表达式:

```
fun main() {
//sampleStart
    val s = "abc"
    println("$s.length is ${s.length}") // 输出 "abc.length is 3"
//sampleEnd
}
```

在多行字符串及转义字符串中都可以使用模板。 如需在多行字符串（不支持反斜杠转义）中的允许作为[标识符（identifier）](https://kotlinlang.org/docs/reference/grammar.html#identifiers)开头的任意符号之前插入美元符 `$`， 请使用以下语法：s

```
val price = """
${'$'}_9.99
"""
```


# 数组

数组是一种保存固定数量相同类型或其子类型的值的数据结构。 Kotlin 中最常见的数组类型是对象类型数组，由 [`Array`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/) 类表示。

> 如果在对象类型数组中使用原生类型，那么会对性能产生影响，因为原生值都[装箱](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html)成了对象。 为了避免装箱开销，请改用[原生类型数组](https://book.kotlincn.net/text/arrays.html#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84)。

## 何时使用数组

当需要满足特殊的底层需求时，可以在 Kotlin 中使用数组。 例如，如果性能要求超出了常规应用程序的需要，或者需要构建自定义的数据结构。 如果没有这些限制，那么请改用[集合](https://book.kotlincn.net/text/collections-overview.html)。

与数组相比，集合具有以下优点：

- 集合可以是只读的，这提供了更多的控制权而支持编写具有明确意图的健壮代码。
- 易于对集合增删元素。相比之下，数组大小是固定的。 对数组增删元素的唯一方式是每次创建一个新数组，效率很低：
    
    ```
    fun main() {
    //sampleStart
        var riversArray = arrayOf("Nile", "Amazon", "Yangtze")
    
        // 使用 += 赋值操作创建了一个新的 riversArray，
        // 复制了原始元素并添加了“Mississippi”
        riversArray += "Mississippi"
        println(riversArray.joinToString())
        // Nile, Amazon, Yangtze, Mississippi
    //sampleEnd
    }
    ```
    

- 可以使用相等操作符（`==`）来检验两个集合是否在结构上相等。但不能对数组使用这个操作符。 相反，必须使用一个特殊函数，关于这点可以参阅[比较数组](https://book.kotlincn.net/text/arrays.html#%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84)了解更多信息。

关于集合的更多信息请参见[集合概述](https://book.kotlincn.net/text/collections-overview.html)。

## 创建数组

在 Kotlin 中创建数组，你可以使用以下方法：
函数，比如 arrayOf ()、arrayOfNulls ()或 emptyArray ()。
数组构造函数。
这个例子使用了 arrayOf ()函数，并将项目值传递给它：

```
fun main() {
//sampleStart
    // Creates an array with values [1, 2, 3]
    val simpleArray = arrayOf(1, 2, 3)
    println(simpleArray.joinToString())
    // 1, 2, 3
//sampleEnd
}
```

This example uses the [`arrayOfNulls()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/array-of-nulls.html#kotlin$arrayOfNulls(kotlin.Int)) function to create an array of a given size filled with `null` elements:

```
fun main() {
//sampleStart
    // Creates an array with values [null, null, null]
    val nullArray: Array<Int?> = arrayOfNulls(3)
    println(nullArray.joinToString())
    // null, null, null
//sampleEnd
}
```

